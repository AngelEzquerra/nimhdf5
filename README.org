* nimhdf5

This repository contains a wrapper for the [[https://www.hdfgroup.org/HDF5/][HDF5 data format]] for the Nim
programming language as well as some work in progress
high-level bindings. 

The raw wrapper dynamically links the libhdf5.so (the main library)
and libhdf5_hl.so (a library containing high-level convenience
functions) libraries at runtime. All public functions of the two
libraries are callable by their corresponding C names and C
arguments. That means the Nim datatypes need to be manually cast to
the corresponding compatible types, if only the wrapper is used.

This is currently in an alpha state, with no guarantees that it will
work for you (but if you use it and let me know it's broken, I'd be
happy to fix it!). The wrapper was built making heavy use of [[https://www.github.com/nim-lang/c2nim][c2nim]] and
the main goal was to have a usable interface for the HDF5 data
format. More advanced features (e.g. single writer / multiple reader)
were of lower priority. Via the wrapper all features should in
principle work, but many have not been tested. 

The high-level bindings now provide a reasonble interface if reading
and writing of groups, datasets and attributes is the use
case. Especially reading comes with a few quirks for now
unfortunately. See [[file:examples/h5_high_level_example.nim]] as an
overview (soon to be cleaned up, split and put into a tutorial form)
on the available features and their usage.

** Compatibility

The wrapper is currently tested using Nim version =0.18.0= and the
current devel branch (=0.18.1=). The previous release =0.17.2= might
potentially still work, but alone it's too much work to support more
than the latest stable release and its devel branch.

The wrapper is built from HDF5 version =1.10.1=.

Linking against the HDF5 =1.8= library is reasonably supported as
well, but requires to use an additional compiler flag for now:
#+BEGIN_SRC sh
-d:H5_LEGACY
#+END_SRC
Currently no checks are done, which compare the library this wrapper
is built upon with the library linking against using some of the
provided HDF5 macros (e.g. H5check, H5get_libversion etc.). The main
reason is explained below. However, as far as the high-level
functionality is concerned at the moment, the only differences arise
in a few constant definitions, whose names slightly changed from =1.8=
to =1.10=. This is what the compiler flags sets accordingly.

The HDF5 headers contain macros for many variables, such as
#+BEGIN_SRC C
#define H5F_ACC_RDONLY	(H5CHECK H5OPEN 0x0000u)
#+END_SRC
where 
#+BEGIN_SRC C
#define H5CHECK          H5check(),
#+END_SRC
and
#+BEGIN_SRC C
#define H5OPEN        H5open(),
#+END_SRC
i.e. it makes use of C's comma operator. However, c2nim currently
[[https://nim-lang.org/docs/c2nim.html#limitations][has no support for it]]. Instead of porting them in some reasonable way,
these macros were converted to simple replacements with the values,
dropping the calls to H5check() and H5open().

The call to H5check() is currently not used at all. Compiling a Nim
program with this wrapper (based on version =1.10.1=) would normally
fail to check against the linked library, if that version is different.

As H5open() is important, the calls are replaced by a single call to
initialize the library at the beginning upon the first call of the
library via [[file:src/nimhdf5/wrapper/H5niminitialize.nim]].

As HDF5 is a very macro heavy library, other important macros may not
have been correctly wrapped to Nim, e.g. determination of correct
sizes of data types. This may cause some weird side-effects (to be
fair, I haven't noticed any!). 

Additionally, Windows support is unknown at this time. The library
name is correctly set for Windows, however an additional header file
=H5FDwindows.h= might have to be wraped.

** Installation

As the state of the library is still in such an early stage, it's not
yet added to the nimble repository. You can either clone this repository
manually 
#+BEGIN_SRC sh
git clone https://github.com/vindaar/nimhdf5
#+END_SRC
in a folder of your choice and call nimble install afterwards:
#+BEGIN_SRC sh
cd nimhdf5
nimble install
#+END_SRC

Or simply make use of nimble's Github interfacing capabilities:
#+BEGIN_SRC sh
nimble install https://github.com/vindaar/nimhdf5
#+END_SRC

** Dependencies

Since I personally need to write [[https://github.com/mratsim/Arraymancer][Arraymancer]] tensors into HDF5 files,
the requirement of Arraymancer is currently hardcoded, despite being
unnecessary if the corresponding procedures are not used.

** Files

The folder [[file:c_headers/][c_headers]] contains the modified HDF5 headers in the state
they were in for a successful c2nim conversion. In some cases the C
header file had to be modified, in others modification to the
resulting .nim file was still necessary.

The folder [[file:examples/][examples]] contains the basic HDF5 C examples (see here:
[[https://support.hdfgroup.org/HDF5/examples/intro.html#c]]) converted to
Nim utilizing the wrapper. 

[[file:examples/h5_create_dataset_hl.nim][h5_high_level_example.nim]] serves as a replacement for a tutorial for
now (tutorial will be added soon!), showcasing (almost) all available
features and their usage.

** Known bugs and quirks

The high level bindings come with several quirks which are good to
know.

- an annoying bug, because of a conversion of datatype names from their
  name without to their name with size attached, can cause a
  `ValueError` to be raised (see issue #9)
- when reading back a dataset with dimension > 1, the returned data is
  returned in a flat `seq`, instead of e.g. a nested
  `seq[seq[<type>]]` as one might expect. 
  The exception is variable length data in case of a 1D dataset
  containing `seq`s of varying sizes. Here a nested seq of the correct
  elements is returned.
- a large fraction of all procs currently rely on a mutable object
  to keep track of the corresponding objects in the H5
  library. However, there are quite a few procs which could work just
  fine on a constant object (see issue #10).
- when grabbing a group or dataset from a H5FileObj via `[](name:
  string)`, a conversion of the string to a distinct `string` type
  `grp_str` or `dset_str` is used to provide a uniform interface for
  both from a file object.
- and many more



** To be done
- tests for many features still missing
- add filters for compression of datasets
- rework return type of reading procs, such that it's possible to
  receive the data in a non-flat `seq`. 
- rewrite parts making better use of available H5 functions
- ... lots and lots more
